From 7523a530494484e8b92e0c8604fb39a51b4887f8 Mon Sep 17 00:00:00 2001
From: Peter Hutterer <peter.hutterer@who-t.net>
Date: Wed, 24 Oct 2018 10:15:58 +1000
Subject: [PATCH 3/4] Split EV_MSC handling out of the EV_SYN handling

The only thing these two had in common was the reset of the event count on
failure. Might as well split them up to make the code more readable.

Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>
Reviewed-by: Ping Cheng <ping.cheng@wacom.com>
(cherry picked from commit 8a6f201fde45b6aef9785bdfbfd0d908ff1c4071)
---
 src/wcmUSB.c | 68 +++++++++++++++++++++++++++++++---------------------
 1 file changed, 41 insertions(+), 27 deletions(-)

diff --git a/src/wcmUSB.c b/src/wcmUSB.c
index be9be6e..cf89ff8 100644
--- a/src/wcmUSB.c
+++ b/src/wcmUSB.c
@@ -59,6 +59,8 @@ static void usbParseEvent(InputInfoPtr pInfo,
 	const struct input_event* event);
 static void usbParseSynEvent(InputInfoPtr pInfo,
 			     const struct input_event *event);
+static void usbParseMscEvent(InputInfoPtr pInfo,
+			     const struct input_event *event);
 static void usbDispatchEvents(InputInfoPtr pInfo);
 static int usbChooseChannel(WacomCommonPtr common, int device_type, unsigned int serial);
 
@@ -994,8 +996,44 @@ static void usbParseEvent(InputInfoPtr pInfo,
 	/* save it for later */
 	private->wcmEvents[private->wcmEventCnt++] = *event;
 
-	if (event->type == EV_MSC || event->type == EV_SYN)
-		usbParseSynEvent(pInfo, event);
+	switch (event->type)
+	{
+		case EV_MSC:
+			usbParseMscEvent(pInfo, event);
+			break;
+		case EV_SYN:
+			usbParseSynEvent(pInfo, event);
+			break;
+		default:
+			break;
+	}
+}
+
+static void usbParseMscEvent(InputInfoPtr pInfo,
+			     const struct input_event *event)
+{
+	WacomDevicePtr priv = (WacomDevicePtr)pInfo->private;
+	WacomCommonPtr common = priv->common;
+	wcmUSBData* private = common->private;
+
+	if (event->code != MSC_SERIAL)
+		return;
+
+	if (event->value != 0)
+	{
+		/* save the serial number so we can look up the channel number later */
+		private->wcmLastToolSerial = event->value;
+	}
+	else
+	{
+		/* we don't report serial numbers for some tools but we never report
+		 * a serial number with a value of 0 - if that happens drop the
+		 * whole frame */
+		LogMessageVerbSigSafe(X_ERROR, 0,
+				      "%s: usbParse: Ignoring event from invalid serial 0\n",
+				      pInfo->name);
+		private->wcmEventCnt = 0;
+	}
 }
 
 /**
@@ -1011,33 +1049,9 @@ static void usbParseSynEvent(InputInfoPtr pInfo,
 	WacomCommonPtr common = priv->common;
 	wcmUSBData* private = common->private;
 
-	if ((event->type == EV_MSC) && (event->code == MSC_SERIAL))
-	{
-		/* we don't report serial numbers for some tools
-		 * but we never report a serial number with a value of 0 */
-		if (event->value == 0)
-		{
-			LogMessageVerbSigSafe(X_ERROR, 0,
-					      "%s: usbParse: Ignoring event from invalid serial 0\n",
-					      pInfo->name);
-			goto skipEvent;
-		}
-
-		/* save the serial number so we can look up the channel number later */
-		private->wcmLastToolSerial = event->value;
-
+	if (event->code != SYN_REPORT)
 		return;
 
-	} else if ((event->type == EV_SYN) && (event->code == SYN_REPORT))
-	{
-		/* end of record. fall through to dispatch */
-	}
-	else
-	{
-		/* not a MSC_SERIAL and not a SYN_REPORT, bail out */
-		return;
-	}
-
 	/* ignore events without information */
 	if ((private->wcmEventCnt < 2) && private->wcmLastToolSerial)
 	{
-- 
2.19.2

