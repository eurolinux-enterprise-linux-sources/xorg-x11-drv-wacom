From de27498001c588e7b290516fa13b8ea6c6cca412 Mon Sep 17 00:00:00 2001
From: Ping Cheng <pinglinux@gmail.com>
Date: Thu, 10 Oct 2013 16:13:55 -0700
Subject: [PATCH 2/6] Fix missing pad/expresskey events issue

Setting PAD_ID should not be limited to just tablets that use
generic BTN_* events. Also, on touch enabled devices, we miss
pad events when touch events are filtered/disabled. Walk through
all channels to make sure all channels that have changed values
are processed.

Reviewed-by: Jason Gerecke <killertofu@gmail.com>
Acked-by: Peter Hutterer <peter.hutterer@who-t.net>
Signed-off-by: Ping Cheng <pingc@wacom.com>
Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>
(cherry picked from commit b154cfa766ce9497379a5cfa38fff64e7d89440b)
---
 src/wcmUSB.c | 29 +++++++++++++++--------------
 1 file changed, 15 insertions(+), 14 deletions(-)

diff --git a/src/wcmUSB.c b/src/wcmUSB.c
index eaaf854..cf27a10 100644
--- a/src/wcmUSB.c
+++ b/src/wcmUSB.c
@@ -1464,11 +1464,13 @@ static void usbParseBTNEvent(WacomCommonPtr common,
 			}
 			if (nkeys >= usbdata->npadkeys)
 				change = 0;
-			else if (!ds->device_type) /* expresskey pressed at startup */
-				ds->device_type = PAD_ID;
 	}
 
 	channel->dirty |= change;
+
+	/* expresskey pressed at startup or missing type */
+	if (!ds->device_type && channel->dirty)
+		ds->device_type = PAD_ID;
 }
 
 /**
@@ -1601,7 +1603,7 @@ static Bool usbIsTabletToolInProx(int device_type, int proximity)
 
 static void usbDispatchEvents(InputInfoPtr pInfo)
 {
-	int i;
+	int i, c;
 	WacomDeviceState *ds;
 	struct input_event* event;
 	WacomDevicePtr priv = (WacomDevicePtr)pInfo->private;
@@ -1722,17 +1724,16 @@ static void usbDispatchEvents(InputInfoPtr pInfo)
 	if (!ds->proximity)
 		private->wcmLastToolSerial = 0;
 
-	/* don't send touch event when touch isn't enabled */
-	if (ds->device_type != TOUCH_ID || common->wcmTouch)
-	{
-		int c;
-		for (c = 0; c < MAX_CHANNELS; c++) {
-			DBG(10, common, "Checking if channel %d is dirty...\n", c);
-			if (common->wcmChannel[c].dirty) {
-				DBG(10, common, "Dirty flag set on channel %d; sending event.\n", c);
-				common->wcmChannel[c].dirty = FALSE;
-				wcmEvent(common, c, &common->wcmChannel[c].work);
-			}
+	for (c = 0; c < MAX_CHANNELS; c++) {
+		ds = &common->wcmChannel[c].work;
+
+		/* walk through all channels */
+		if (common->wcmChannel[c].dirty) {
+			DBG(10, common, "Dirty flag set on channel %d; sending event.\n", c);
+			common->wcmChannel[c].dirty = FALSE;
+			/* don't send touch event when touch isn't enabled */
+			if (ds->device_type != TOUCH_ID || common->wcmTouch)
+				wcmEvent(common, c, ds);
 		}
 	}
 }
-- 
1.9.0

